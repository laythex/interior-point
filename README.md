# Поиск минимума линейно-квадратичного функционала.

Все входные параметры вносятся в соответствующий раздел в main.cpp.

Единственные ограничения на x: Ax <= b. Я не заметил x >= 0 в условии задачи, поэтому решил так. 
По сути, все что добавляется, это разделение каждой переменной на ее положительную и отрицательную составляющую.

Самой сложной подзадачей оказался поиск внутренней точки. Для этого пришлось решить задачу симплекс методом, минимизируя новые переменные - добавки.
Реализация "симплекс метода" в Interior.cpp. В кавычках, потому что он подогнан под мою задачу.
Его матрица - (A, -A, E_m, E_m).
Две матрицы A для положительных и отрицательных составляющих x.
Первая единичная матрица для переменных, превращающих неравенства в равенства.
После такого приведения к каноническому виду добавляем еще m переменных, которые будем минимизировать.

Для того чтобы найти внутреннюю точку, а не точку на границе, вводится еще одна переменная t (предпоследний столбец), которая усиливает существующие ограничения.
Ее мы постараемся максимизировать, чтобы максимально отойти от границы: Ax + t <= b -> Ax < b, при t > 0.

Дальше в программе есть мутненький момент с идентификацией неограниченности области. Это соответствует тому, что мы не можем найти входящую в базис переменную.
Я еще попробую в этом разобраться.

Сам метод внутренней точки, при правильно подобранных mu, работает на удивление хорошо. Находит решения на границе.
Если функция в области неограничена снизу, то свалится в бесконечный цикл, но предупредив о потенциальной опасности.
Также может свалиться в локальный минимум, но это уже проблема пользователя.

Градиент и гессиан нашел аналитически, логарифм хорошо дифференцируется.
Оптимальный шаг подбирается по градиенту и гессиану из разложения функционала до второго порядка.

Если найдете пример, на котором что-то ломается, сообщите. И если надо что-то добавить, тоже.

Компиляция и запуск стандартно через cmake.
