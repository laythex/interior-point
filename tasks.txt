Задача 1

Решается за две итерации, сходится к глобальному минимуму,
он лежит в допустимой области

size_t n = 2;
Matrix Q = Matrix({{2, 0}, {0, 1}});
std::vector<double> c = {-4, -2};

size_t m = 4;
Matrix A = Matrix({{1, 2}, {-2, -1}, {-1, 0}, {0, -1}});
std::vector<double> b = {4, -1, 0, 0};

double mu_0 = 0.1;
double mu_next(double mu_k, unsigned k) {
    return mu_k * 0.999;
}

double eps = 0.0001;

bool is_x0_provided = false;
std::vector<double> x0 = {0, 0};


Результат:
x0 = 1 1 
k_fin = 2
x_opt = 1.02432 0.980895 
f(x_opt) = -2.99845

//===================================================//

Задача 2

Уменьшил множитель в mu_next, сошлось за 61 итерацию к глобальному минимуму,
он опять лежит в допустимой области

size_t n = 2;
Matrix Q = Matrix({{2, -1}, {-1, 1}});
std::vector<double> c = {-4, 0};

size_t m = 4;
Matrix A = Matrix({{-1, -1}, {1, 2}, {-1, 0}, {0, -1}});
std::vector<double> b = {-1, 20, 0, 0};

double mu_0 = 0.1;
double mu_next(double mu_k, unsigned k) {
    return mu_k * 0.9;
}

double eps = 0.0001;

bool is_x0_provided = false;
std::vector<double> x0 = {0, 0};


Результат:
x0 = 5 5 
k_fin = 61
x_opt = 2.00013 2.0002 
f(x_opt) = -4

//===================================================//

Задача 3

Сошлось за 68 итераций
Правильность проверить не могу, функционал трехмерный
Знаю только что глобальный минимум лежит вне допустимой области,
а полученная точка удовлетворяет условиям

size_t n = 3;
Matrix Q = Matrix({{1, -2, 1}, {-2, 5, -4}, {1, -4, 6}});
std::vector<double> c = {-3, 9, 11};

size_t m = 6;
Matrix A = Matrix({{-1, -5, -1}, {1, 1, 1}, {-1, 0, 1}, {-1, 0, 0}, {0, -1, 0}, {0, 0, -1}});
std::vector<double> b = {-6, 7, 0, 0, 0, 0};

double mu_0 = 0.1;
double mu_next(double mu_k, unsigned k) {
    return mu_k * 0.9;
}

double eps = 0.0001;

bool is_x0_provided = false;
std::vector<double> x0 = {0, 0};


Результат:
x0 = 2.8 1.4 1.4 
k_fin = 68
x_opt = 2.89769 1.00412 2.55154e-05 
f(x_opt) = 2.14359

//===================================================//

Задача 4

Мой алгоритм правильно распознал неограниченную допустимую область
Как вы и написали, добавил проверку на то, что прирост модуля целевой функции
увеличивается в течение десяти итераций. Это действительно помогло и не сломало предыдущие задачи

size_t n = 2;
Matrix Q = Matrix({{-1, 0}, {0, -1}});
std::vector<double> c = {0, 0};

size_t m = 3;
Matrix A = Matrix({{-1, -2}, {-1, 0}, {0, -1}});
std::vector<double> b = {-4, 0, 0};

double mu_0 = 0.1;
double mu_next(double mu_k, unsigned k) {
    return mu_k * 0.999;
}

double eps = 0.0001;

bool is_x0_provided = false;
std::vector<double> x0 = {0, 0};


Результат:
Исследуемая область неограничена
Удостоверьтесь, что функция ограничена снизу внутри области

(итерация 1668)
Скорее всего, целевая функция не ограничена снизу в допустимой области
